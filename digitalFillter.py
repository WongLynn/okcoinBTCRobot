#-*- coding: utf-8 -*-def whileMinAndMax(ds):    minp = 0    maxp = 0    minx = ds[0]    maxx = ds[0]    for x in range(len(ds)):        if ds[x] < minx:            minx = ds[x]            minp = x        if ds[x] > maxx:            maxx = ds[x]            maxp = x    return minp,maxpdef getMeanRmMinAndMax(ds):    aum = 0.0    minp,maxp = whileMinAndMax(ds)    for x in range(len(ds)):        if x != minp and x != maxp:            aum += ds[x]    pv = aum/(len(ds)-2)    return pv#得到pn个数据的平均值滤波方def digitalFillter5(dats,pn = 70):    newdats = []    for d in range(len(dats)):        if d >= pn:            ttmp = getMeanRmMinAndMax(dats[d-pn:d])            newdats.append(ttmp)        else:            ttmp = getMeanRmMinAndMax(dats[d:d+pn-1])            newdats.append(ttmp)    return newdats#得到一组数据的斜率数组#dats,原始数据,magn,得到的斜率放大倍数，baseVal,结果所要加的基数def digitalGradient(dats,magn = 1.0,baseVal = 0):    xilvs = []    for d in range(len(dats)):        if d == 0:            last0 = dats[d]            xilvs.append(baseVal + magn*(dats[1]-dats[d])/1)        else:            tx = dats[d]            xilvs.append(baseVal + magn*(tx-last0)/1)            last0 = tx    #print xilvs    return xilvsdef getDigitalAreaForList(dats):    area = 0.0    for i in range(len(dats)):        if i+1 < len(dats) -1:            area += (dats[i] + dats[i+1])/2.0        else:            area += (dats[len(dats)-2] + dats[len(dats)-1])/2.0    return area#得到上一个脉冲的面积,dats:数组曲线数据,selectPs:过零点的位置def getDigitalArea(dats,selectPs):    areas = {}#前边的所有过零面积    arsk = []    for n in range(len(selectPs)):        if n+1 < len(selectPs):            earedats = dats[selectPs[n]:selectPs[n+1]]            eartmp = getDigitalAreaForList(earedats)            areas[str(selectPs[n+1])] = eartmp            arsk.append(selectPs[n+1])    eartmp = 0.0#最后的上升或下降阶段面积    if selectPs[len(selectPs) -1] < len(dats)-1:        earedats = dats[selectPs[len(selectPs)-1]:]        eartmp = getDigitalAreaForList(earedats)    return areas,eartmp#波峰波谷位置点以及这些点上斜率的变化率，波峰波谷值,dats,原始数据,clamp,左右两边最大值的钳位值。isGreateThen,是否要求大于钳位值def digitalPeakAndValley(dats,buyclamp = 1.0,sellclamp = 1.0,fillter = 15):    xl = digitalGradient(dats, 100.0, 0)    xl = digitalFillter5(xl,fillter)    lastx = xl[0]    fzx = []    for x in range(len(xl)):        if x != 0 and lastx > 0 and xl[x] < 0.0:            lastx = xl[x]            fzx.append(x)        elif x != 0 and lastx < 0 and xl[x] > 0.0:            lastx = xl[x]            fzx.append(x)        elif x != 0 and lastx != 0 and xl[x] == 0:            lastx = xl[x]            fzx.append(x)        elif x != 0 and lastx == 0:            lastx = xl[x]            #     print 'get PeakValley count:%d'%(len(fzx))#     print fzx[len(fzx)-1]    isSell = False    fz = []    dicarea,ear0 = getDigitalArea(xl, fzx)    for t in fzx:        if dicarea.has_key(str(t)) and dicarea[str(t)] > sellclamp:            if not isSell:                fz.append({'x':t,'fa':dicarea[str(t)]})                isSell = True        elif dicarea.has_key(str(t)) and dicarea[str(t)] < -buyclamp:            if isSell:                fz.append({'x':t,'fa':dicarea[str(t)]})                isSell = False    return fz,ear0,xl[len(xl)-1] #当前面积组，最后的点价格斜率#主方法def main():    pass#在这里测试代码#     ds = [111,3,4,1,5,6,7,89,100,99,3,4434,123,4,5,6,7,8,9,7,345,5,4,3,2,1,12,3,4,556,]#     dsn = digitalFillter5(ds)#     print len(ds)#     print len(dsn)#     print ds#     print dsn    if __name__ == '__main__':    main()